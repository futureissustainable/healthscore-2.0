turn this react html code into a next.js vercel ready project:


Uses a serverless backend to hide keys, rate-limits to 10 scans/IP/day, and supports payments and plan limits. using node.js, upstash and vercel. (with their api keys in environment variables in vercel API_KEY, UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN)


Also improve mobile-optimized UI, also for mobile fix the photo capture and photo upload, as right now nothing happens when you try to input a photo on mobile.


<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>ULTRASCORE - AI Product Analyzer</title>

    

    <link href="https://api.fontshare.com/v2/css?f[]=general-sans@1&display=swap" rel="stylesheet">

    

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>

    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>


    <style>

        body {

            font-family: 'General Sans', sans-serif;

        }

    </style>

</head>

<body>

    <div id="root"></div>


<script type="text/babel">

    const { useState, useRef, useCallback, memo } = React;


    // --- GEMINI AI API SERVICE ---

    const analyzeProduct = async (prompt, base64Image) => {

        try {

            const result = await analyzeProductWithGemini(prompt, base64Image);

            return result;

        } catch (error) {

            console.error("Error analyzing product:", error);

            throw new Error(error.message || 'Failed to get analysis from AI.');

        }

    };


    // THIS IS THE CORE AI LOGIC - IT SHOULD BE MOVED TO YOUR BACKEND

    const analyzeProductWithGemini = async (textInput, base64Image) => {

        const API_KEY = "AIzaSyCbiA_MCBeNonsNH1YxKKlp0qOIqnHnljE"; // <-- IMPORTANT: Keep this on the server!

        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + API_KEY;

        const prompt = `

            You are ULTRASCORE, a highly objective and data-driven AI expert in analyzing consumer products. Your primary goal is to analyze user input (text and/or image) to identify and evaluate a consumer product for health.


            **Core Directives:**

            1.  **NEVER REFUSE TO ANSWER:** You must ALWAYS provide a full analysis in the JSON format.

            2.  **CALCULATE A TRUST SCORE:** You must ALWAYS provide a "trustScore" from 0 to 100, reflecting your confidence in the analysis.


            **Response Workflow:**

            1.  **Analyze & Estimate:**

                - Set "isConsumerProduct" to true.

                - Identify the product's likely full name and category.

                - Extract or estimate all required data points. Lower your trust score if you estimate heavily.

            2.  **Generate Healthier Options:**

                -   **"healthierAddon":**

                    1. Identify a single, actionable tip to make the product healthier (add an ingredient, change preparation, or choose a better version).

                    2. In "productName", provide the FULL, NEW product name for a subsequent search (e.g., for 'Toast', return 'Toast with Avocado').

                    3. In "description", briefly explain the benefit of the change.

                    4. In "scoreBoost", estimate the point increase (0-30) this change would provide.

                    5. **CRITICAL:** If you cannot confidently suggest an improvement, set this to null.

                -   **"topInCategory":** 1. Provide exactly one top-tier, exemplary product from the same broad category.

                    2. **CRITICAL:** This product MUST be a clear and significant health improvement over the analyzed product. If you cannot find one with high confidence, set it to null.

            3.  **Determine Best In Class:** If the product is an exemplary, top-tier example of health in its specific sub-category (e.g., plain Greek yogurt, not just 'dairy'), set "isBestInClass" to true. Otherwise, set it to false.

            4.  **Fill JSON:** Complete the entire JSON structure below. You MUST respond ONLY with a valid JSON object.


            JSON Structure:

            {

              "isConsumerProduct": boolean,

              "isBestInClass": boolean | null,

              "rejectionReason": string | null,

              "trustScore": number | null,

              "productName": string | null,

              "productCategory": "Food" | "Beverage" | "PersonalCare" | null,

              "processingLevel": "Unprocessed/Minimally Processed" | "Processed Culinary Ingredients" | "Processed Foods" | "Ultra-Processed Foods" | null,

              "harmfulAdditives": { "hasArtificialSweeteners": boolean, "hasIndustrialEmulsifiers": boolean, "hasArtificialColorsFlavors": boolean } | null,

              "nutrientsPer100g": { "calories": number, "carbohydratesG": number, "totalFatG": number, "proteinG": number, "addedSugarG": number, "sodiumMg": number, "saturatedFatG": number, "unsaturatedFatG": number, "fiberG": number } | null,

              "proteinQuality": "High-Quality Whole-Food" | "High-Quality Plant-Based" | "None" | null,

              "hasTransFat": boolean | null,

              "wholeFoodContentPercentage": number | null,

              "personalCareDetails": { "harmfulIngredients": string[], "beneficialIngredients": string[], "hasFragrance": boolean, "isCrueltyFree": boolean } | null,

              "healthierAddon": { "productName": string, "description": string, "scoreBoost": number } | null,

              "topInCategory": { "productName": string, "description": string } | null

            }

        `;


        const requestBody = {

            contents: [{ parts: [{ text: prompt }, { text: `Product name/description: ${textInput}` }] }],

            generationConfig: { responseMimeType: "application/json", temperature: 0.2 }

        };


        if (base64Image) { requestBody.contents[0].parts.push({ inline_data: { mime_type: "image/jpeg", data: base64Image } }); }


        const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });


        if (!response.ok) {

            const errorBody = await response.json(); console.error("Gemini API Error:", errorBody);

            throw new Error(`AI API request failed: ${errorBody.error?.message || response.statusText}`);

        }


        const data = await response.json();

        

        try {

            if (!data.candidates || data.candidates.length === 0) { throw new Error("AI returned no response. The input may have been blocked."); }

            const jsonString = data.candidates[0].content.parts[0].text;

            const parsedJson = JSON.parse(jsonString);

            if (!parsedJson.isConsumerProduct) { throw new Error(parsedJson.rejectionReason || "The item is not a recognized consumer product."); }

            return parsedJson;

        } catch (e) {

            console.error("Failed to parse AI response:", e, data?.candidates?.[0]?.content?.parts?.[0]?.text);

            throw new Error("AI returned an invalid response format.");

        }

    };

    

    const performCommonSenseCheck = async (productData, initialScore) => {

        if (initialScore.finalScore < 20) return { ...initialScore, overrideReason: null };

        const API_KEY = "AIzaSyCbiA_MCBeNonsNH1YxKKlp0qOIqnHnljE";

        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + API_KEY;

        const prompt = `You are a safety and common sense validation AI. Your task is to identify dangerously misleading health scores. The algorithm scores based on nutritional data but can be fooled by inedible or poisonous items (e.g., scoring 'Cyanide Water' as 100). Product Name: "${productData.productName}", Initial Score: ${initialScore.finalScore}/100. **Task:** Evaluate if the score is absurd or dangerous (Toxic, Inedible, etc.). **Response Format:** If plausible, respond ONLY with: {"isMisleading": false}. If dangerous, respond ONLY with: {"isMisleading": true, "correctedScore": 0, "reason": "A brief, user-facing explanation."}. Only override for clear, unambiguous cases of danger.`;

        const requestBody = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", temperature: 0.0 } };

        try {

            const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });

            if (!response.ok) { console.warn("Common sense check failed, returning original score."); return { ...initialScore, overrideReason: null }; }

            const data = await response.json();

            const validation = JSON.parse(data.candidates[0].content.parts[0].text);

            if (validation.isMisleading) {

                console.warn(`Common sense override for "${productData.productName}". Reason: ${validation.reason}`);

                return { ...initialScore, finalScore: validation.correctedScore, category: 'Avoid', overrideReason: validation.reason, healthierAddon: null, topInCategory: null, breakdown: { baseScore: initialScore.breakdown.baseScore, adjustments: [{ reason: `Safety Override: ${validation.reason}`, points: -100 }] } };

            }

            return { ...initialScore, overrideReason: null };

        } catch (error) {

            console.warn("Failed to perform common sense check. Returning original score.", error);

            return { ...initialScore, overrideReason: null };

        }

    };



    // --- SCORE CALCULATOR LOGIC ---

    const calculateFoodScore = (data) => {

        const baseline = 50; let score = baseline; const adjustments = [];

        const nutrients = data.nutrientsPer100g || {};

        const addAdjustment = (reason, points) => { if (points !== 0) { adjustments.push({ reason, points }); score += points; } };

        

        switch (data.processingLevel) {

            case "Unprocessed/Minimally Processed": addAdjustment("NOVA Group 1", 15); break;

            case "Processed Culinary Ingredients": addAdjustment("NOVA Group 2", 8); break;

            case "Processed Foods": addAdjustment("NOVA Group 3", 0); break;

            case "Ultra-Processed Foods": addAdjustment("NOVA Group 4", -8); break;

        }


        const fruitAndVegKeywords = ['apple', 'banana', 'orange', 'strawberry', 'grape', 'avocado', 'tomato', 'potato', 'carrot', 'broccoli', 'spinach', 'lettuce', 'cucumber', 'pepper', 'onion', 'garlic', 'mango', 'pineapple', 'blueberry', 'raspberry', 'kale', 'celery'];

        const productNameLower = data.productName?.toLowerCase() || '';

        if (data.processingLevel === "Unprocessed/Minimally Processed" && fruitAndVegKeywords.some(keyword => productNameLower.includes(keyword))) {

            addAdjustment("Whole Fruit/Vegetable", 5);

        }


        let positivePoints = 0;

        const fiber = nutrients.fiberG ?? 0;

        if (fiber >= 6) positivePoints += 8; else if (fiber >= 3) positivePoints += 5; else if (fiber >= 1.5) positivePoints += 3;

        const unsatFat = nutrients.unsaturatedFatG ?? 0; const satFat = nutrients.saturatedFatG ?? 0;

        if (satFat > 0) { const ratio = unsatFat / satFat; if (ratio >= 2.0) positivePoints += 5; else if (ratio >= 1.0) positivePoints += 3; } else if (unsatFat > 0) { positivePoints += 3; }

        if (data.proteinQuality === "High-Quality Whole-Food") positivePoints += 5; else if (data.proteinQuality === "High-Quality Plant-Based") positivePoints += 3;

        if (data.wholeFoodContentPercentage >= 40) positivePoints += 3;

        addAdjustment("Positive Modifiers", Math.min(20, positivePoints));

        

        let negativePoints = 0;

        const sugar = nutrients.addedSugarG ?? 0;

        if (sugar > 22.5) negativePoints += 20; else if (sugar >= 15) negativePoints += 15; else if (sugar >= 5) negativePoints += 10; else if (sugar > 0) negativePoints += 5;

        const sodium = nutrients.sodiumMg ?? 0;

        if (sodium >= 600) negativePoints += 8; else if (sodium >= 300) negativePoints += 5; else if (sodium >= 120) negativePoints += 3;

        if (data.hasTransFat) negativePoints += 5;

        let additivePenalty = 0;

        if (data.harmfulAdditives?.hasArtificialSweeteners) additivePenalty += 3; if (data.harmfulAdditives?.hasIndustrialEmulsifiers) additivePenalty += 3; if (data.harmfulAdditives?.hasArtificialColorsFlavors) additivePenalty += 3;

        negativePoints += Math.min(5, additivePenalty);

        addAdjustment("Negative Modifiers", -Math.min(30, negativePoints));


        const standardScore = Math.round(score);

        

        if (standardScore >= 80) {

            let bonusPotential = 0;

            const protein = nutrients.proteinG ?? 0;

            if (protein > 25) bonusPotential += (protein - 25);

            if (fiber > 10) bonusPotential += (fiber - 10) * 1.5;

            if (unsatFat > 20 && satFat < 4) bonusPotential += (unsatFat - 20);

            if (sugar < 1) bonusPotential += 10;

            if (sodium < 50) bonusPotential += 10;

            if (bonusPotential > 0) {

                const maxBonus = 19;

                const scalingFactor = 40;

                const bonusPoints = Math.round(maxBonus * (1 - Math.exp(-bonusPotential / scalingFactor)));

                if (bonusPoints > 0) {

                    const finalExceptionalScore = 80 + bonusPoints;

                    const pointsToAdd = finalExceptionalScore - standardScore;

                    if (pointsToAdd > 0) {

                       addAdjustment("Exceptional Profile", pointsToAdd);

                    }

                }

            }

        }


        let finalScore = Math.max(0, Math.min(100, Math.round(score)));

        const isBestInClass = data.isBestInClass === true;

        

        if (isBestInClass && finalScore < 100) {

            const bonusPoints = Math.min(10, 100 - finalScore);

            if (bonusPoints > 0) {

                addAdjustment("⭐ Best In Class", bonusPoints);

                finalScore += bonusPoints;

            }

        }


        if (productNameLower.includes('water') && (!nutrients || (nutrients.addedSugarG === 0 && nutrients.sodiumMg === 0))) {

            return { finalScore: 100, isBestInClass: true, trustScore: data.trustScore || 99, category: 'Excellent', productName: data.productName, breakdown: { baseScore: 100, adjustments: [] }, healthierAddon: null, topInCategory: null, nutrients: null };

        }


        let category;

        if (finalScore >= 90) category = 'Excellent'; else if (finalScore >= 70) category = 'Good'; else if (finalScore >= 50) category = 'Moderate'; else if (finalScore >= 30) category = 'Limit'; else category = 'Avoid';

        

        return { 

            finalScore, isBestInClass, trustScore: data.trustScore, category, productName: data.productName, 

            breakdown: { baseScore: baseline, adjustments }, healthierAddon: data.healthierAddon || null,

            topInCategory: data.topInCategory || null, nutrients: data.nutrientsPer100g 

        };

    };

    const calculatePersonalCareScore = (data) => {

        const baseline = 60; const adjustments = []; let score = baseline; const details = data.personalCareDetails;

        const addAdjustment = (reason, points) => { adjustments.push({ reason, points }); score += points; };

        details.harmfulIngredients?.forEach(ing => { if (/paraben/i.test(ing)) addAdjustment("Contains Parabens", -8); else if (/sulfate|sls|sles/i.test(ing)) addAdjustment("Contains Sulfates", -3); else if (/phthalate/i.test(ing)) addAdjustment("Contains Phthalates", -8); });

        if (details.hasFragrance) addAdjustment("Contains Synthetic Fragrance", -3);

        details.beneficialIngredients?.forEach(ing => { if (/ceramide/i.test(ing)) addAdjustment("Contains Ceramides", 5); else if (/vitamin e|tocopherol/i.test(ing)) addAdjustment("Contains Vitamin E", 3); });

        if (details.isCrueltyFree) addAdjustment("Cruelty-Free", 3);

        

        let finalScore = Math.max(0, Math.min(100, Math.round(score)));

        const isBestInClass = data.isBestInClass === true;


        if (isBestInClass && finalScore < 100) {

            const bonusPoints = Math.min(10, 100 - finalScore);

            if (bonusPoints > 0) {

                addAdjustment("⭐ Best In Class", bonusPoints);

                finalScore += bonusPoints;

            }

        }


        let category;

        if (finalScore >= 90) category = 'Excellent'; else if (finalScore >= 70) category = 'Good'; else if (finalScore >= 50) category = 'Moderate'; else if (finalScore >= 30) category = 'Limit'; else category = 'Avoid';

        

        return { 

            finalScore, isBestInClass, trustScore: data.trustScore, category, productName: data.productName,

            breakdown: { baseScore: baseline, adjustments }, healthierAddon: data.healthierAddon || null,

            topInCategory: data.topInCategory || null, nutrients: null 

        };

    }

    const calculateUltraScore = (data) => {

        if (!data.isConsumerProduct || !data.productCategory) { throw new Error("Cannot calculate score for a non-consumer item."); }

        switch (data.productCategory) {

            case "Food": case "Beverage": return calculateFoodScore(data);

            case "PersonalCare": return calculatePersonalCareScore(data);

            default: throw new Error(`Scoring not implemented for category: ${data.productCategory}`);

        }

    };


    // --- UI Components ---

    const CameraIcon = memo(({ className }) => ( <svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" /></svg>));

    const ArrowPathIcon = memo(({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-3.181-4.991v4.99" /></svg>));

    const ScanIcon = memo(({ className }) => ( <svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M7.5 3.75H6A2.25 2.25 0 003.75 6v1.5M16.5 3.75H18A2.25 2.25 0 0120.25 6v1.5m0 9.75v1.5A2.25 2.25 0 0118 20.25h-1.5m-9.75 0H6A2.25 2.25 0 013.75 18v-1.5M12 12.75a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z" /><path strokeLinecap="round" strokeLinejoin="round" d="M12 18.75a6.75 6.75 0 000-13.5" /></svg>));

    const GaugeIcon = memo(({ className }) => ( <svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M8.25 7.5l.415-.207a.75.75 0 011.085.67V10.5m0 0h6m-6 0a2.25 2.25 0 00-2.25 2.25v3.75a2.25 2.25 0 002.25 2.25h4.5a2.25 2.25 0 002.25-2.25V12.75a2.25 2.25 0 00-2.25-2.25H10.5m-2.25 0a2.25 2.25 0 00-2.25-2.25v-1.5a2.25 2.25 0 002.25-2.25H15M12 14.25a.75.75 0 01.75-.75h.008a.75.75 0 01.75.75v.008a.75.75 0 01-.75.75H12.75a.75.75 0 01-.75-.75v-.008z" /></svg>));

    const DecideIcon = memo(({ className }) => ( <svg className={className} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>));

    const ArrowUpRightIcon = memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M4.5 19.5l15-15m0 0H8.25m11.25 0v11.25" /></svg>);

    const SparklesIcon = memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM18 13.5l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 18l-1.035.259a3.375 3.375 0 00-2.456 2.456L18 21.75l-.259-1.035a3.375 3.375 0 00-2.456-2.456L14.25 18l1.035-.259a3.375 3.375 0 002.456-2.456L18 13.5z" /></svg>);

    const StarIcon = memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.007z" clipRule="evenodd" /></svg>);


    const GrainyAuroraBackground = memo(() => ( <React.Fragment><svg className="absolute w-0 h-0" aria-hidden="true"><filter id="grainy"><feTurbulence type="fractalNoise" baseFrequency="0.75" numOctaves="1" stitchTiles="stitch" /><feColorMatrix type="saturate" values="0" /></filter></svg><div className="absolute top-0 left-0 w-full h-full overflow-hidden -z-20"><div className="absolute -top-[10rem] right-[5rem] w-[40rem] h-[40rem] rounded-full bg-gradient-radial from-green-300/40 to-transparent blur-3xl animate-[pulse_8s_ease-in-out_infinite]" /><div className="absolute top-[10rem] -right-[10rem] w-[50rem] h-[50rem] rounded-full bg-gradient-radial from-red-300/30 to-transparent blur-3xl animate-[pulse_10s_ease-in-out_infinite_2s]" /></div><div className="absolute top-0 left-0 w-full h-full -z-10 opacity-10" style={{ filter: 'url(#grainy)', pointerEvents: 'none' }} /></React.Fragment>));

    const Header = memo(() => ( <header className="absolute top-0 left-0 right-0 z-20"><nav className="container mx-auto max-w-7xl px-6 py-6 flex justify-between items-center"><div className="text-2xl font-bold text-slate-900 tracking-wide">ULTRASCORE</div></nav></header>));

    const FeatureCard = memo(({ icon, title, description }) => ( <div className="relative overflow-hidden rounded-2xl border border-slate-200 bg-white p-6 shadow-sm transition-shadow hover:shadow-md"><div className="absolute -top-4 -right-4 h-24 w-24 rounded-full bg-green-50/50"></div><div className="relative"><div className="mb-4 flex h-14 w-14 items-center justify-center rounded-xl bg-gradient-to-br from-green-100 to-emerald-200 text-green-600">{icon}</div><h3 className="mb-2 text-[1.6rem] leading-[1.25em] font-medium text-slate-800 tracking-tight">{title}</h3><p className="text-[0.9rem] leading-[1.6em] font-light text-slate-600">{description}</p></div></div>));

    const SearchBar = ({ onSearch, isLoading }) => {

        const [inputValue, setInputValue] = useState(''); const fileInputRef = useRef(null);

        const handleSubmit = (e) => { e.preventDefault(); if (inputValue.trim() && !isLoading) { onSearch(inputValue.trim()); } };

        const handleFileChange = (e) => { const file = e.target.files?.[0]; if (file) { const reader = new FileReader(); reader.onloadend = () => { const base64String = reader.result?.toString().split(',')[1]; if(base64String) { onSearch(file.name, base64String); } }; reader.readDataURL(file); } };

        return ( <form onSubmit={handleSubmit} className="relative mt-8 max-w-xl mx-auto"><div className="absolute -inset-2.5 rounded-2xl bg-gradient-to-r from-red-400 via-yellow-400 to-green-500 opacity-15 blur-3xl animate-pulse" style={{ animationDuration: '6s' }}></div><div className="relative flex items-center w-full bg-slate-50/70 backdrop-blur-lg rounded-xl p-1 shadow-lg ring-1 ring-black/5"><input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} disabled={isLoading} className="flex-1 w-full h-10 bg-transparent text-slate-900 outline-none placeholder-slate-500 px-4" placeholder="e.g., 'Cheerios', 'Avocado', or 'Head and Shoulders'" /><input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" className="hidden" /><button type="button" aria-label="Scan with camera" onClick={() => fileInputRef.current?.click()} disabled={isLoading} className="ml-1 p-2 rounded-lg bg-slate-800 text-white hover:bg-slate-700 transition-colors disabled:bg-slate-400"><CameraIcon className="w-6 h-6"/></button></div></form> );

    };


    const SuggestionCard = memo(({ title, item, onSearch, icon, bgColor, borderColor, titleColor }) => {

    if (!item || !item.productName) return null;

    return (

        <button

            onClick={onSearch}

            className={`w-full text-left p-3 rounded-lg border ${bgColor} ${borderColor} transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500`}

        >

            <div className="flex items-start gap-3">

                <div className="flex-shrink-0 pt-1">{icon}</div>

                <div className="flex-grow">

                    <h5 className={`text-xs font-bold uppercase tracking-wider ${titleColor}`}>{title}</h5>

                    <p className="font-semibold text-slate-800 mt-1">{item.productName}</p>

                    <p className="text-xs text-slate-600 mt-1">{item.description}</p>

                </div>

            </div>

        </button>

    );

});


    const _ScoreDisplay = ({ scoreData, onReset, onSearch }) => {

        const { finalScore, trustScore, category, productName, breakdown, healthierAddon, topInCategory, nutrients, overrideReason, isBestInClass } = scoreData;

        const [isExpanded, setIsExpanded] = useState(false);

        const handleSuggestionSearch = (newTerm) => onSearch(newTerm, null, finalScore);


        // START: FIX - Logic to extract characteristics and clean the product name

        const characteristicKeywords = ['homemade', 'raw', 'organic'];

        let characteristics = [];

        let cleanedProductName = productName || '';


        characteristicKeywords.forEach(keyword => {

            const regex = new RegExp(`\\b${keyword}\\b`, 'ig');

            const matches = cleanedProductName.match(regex);

            if (matches) {

                // Capitalize and add unique matches to the characteristics array

                matches.forEach(match => {

                    const formattedMatch = match.charAt(0).toUpperCase() + match.slice(1).toLowerCase();

                    if (!characteristics.includes(formattedMatch)) {

                        characteristics.push(formattedMatch);

                    }

                });

                cleanedProductName = cleanedProductName.replace(regex, '');

            }

        });

        cleanedProductName = cleanedProductName.trim().replace(/\s\s+/g, ' ');

        // END: FIX


        let mainDish = cleanedProductName;

        let extras = null;

        const separators = [' with ', ', ', ' and '];

        let firstSeparatorIndex = -1;

        

        for (const sep of separators) {

            const index = mainDish.toLowerCase().indexOf(sep);

            if (index > 0 && (firstSeparatorIndex === -1 || index < firstSeparatorIndex)) {

                firstSeparatorIndex = index;

            }

        }

        if (firstSeparatorIndex !== -1) {

            extras = mainDish.substring(firstSeparatorIndex).trim();

            mainDish = mainDish.substring(0, firstSeparatorIndex).trim();

        }

        

        const categoryStyles = {

            Excellent: { bg: 'bg-green-100', text: 'text-green-800', gradient: 'from-green-500 to-emerald-600', stroke: 'stroke-green-500' },

            Good: { bg: 'bg-lime-100', text: 'text-lime-800', gradient: 'from-lime-500 to-green-500', stroke: 'stroke-lime-500' },

            Moderate: { bg: 'bg-yellow-100', text: 'text-yellow-800', gradient: 'from-yellow-400 to-amber-500', stroke: 'stroke-yellow-400' },

            Limit: { bg: 'bg-orange-100', text: 'text-orange-800', gradient: 'from-orange-500 to-red-500', stroke: 'stroke-orange-500' },

            Avoid: { bg: 'bg-red-100', text: 'text-red-800', gradient: 'from-red-500 to-rose-700', stroke: 'stroke-red-500' },

        };

        const styles = categoryStyles[category];

        const circumference = 2 * Math.PI * 52;

        const strokeDashoffset = circumference - (finalScore / 100) * circumference;

        

        const AdjustmentRow = ({ adj }) => (

            <div className="flex justify-between items-center py-2 border-b border-slate-200 last:border-b-0">

                <span className="text-sm text-slate-600">{adj.reason}</span>

                <span className={`text-sm font-bold ${adj.points >= 0 ? 'text-green-600' : 'text-red-600'}`}>

                    {adj.points > 0 ? `+${adj.points}` : adj.points}

                </span>

            </div>

        );


        const Macro = ({ label, value, unit }) => (

            <div className="text-center">

                <p className="text-xs text-slate-500">{label}</p>

                <p className="font-bold text-slate-700">{value ?? '0'}{unit}</p>

            </div>

        );


        const NutritionInfo = ({ data }) => {

            if (!data) return null;

            return (

                <div className="w-full mt-4">

                    <p className="text-center text-xs text-slate-400 font-semibold uppercase tracking-wider mb-2">Macros per 100g</p>

                    <div className="grid grid-cols-3 gap-y-2 gap-x-4 max-w-xs mx-auto">

                        <Macro label="Protein" value={Math.round(data.proteinG)} unit="g" />

                        <Macro label="Carbs" value={Math.round(data.carbohydratesG)} unit="g" />

                        <Macro label="Fat" value={Math.round(data.totalFatG)} unit="g" />

                        <Macro label="Fiber" value={Math.round(data.fiberG)} unit="g" />

                        <Macro label="Sugar" value={Math.round(data.addedSugarG)} unit="g" />

                        <Macro label="Calories" value={Math.round(data.calories)} unit=" kcal" />

                    </div>

                </div>

            );

        };

        

        return (

            <div className="w-full max-w-sm sm:max-w-md min-h-[550px] mx-auto bg-white/60 backdrop-blur-xl rounded-3xl border border-slate-200 shadow-lg p-4 sm:p-6 flex flex-col items-center animate-fade-in">

                

                <div className="w-full flex justify-between items-baseline gap-4 px-1">

                    <div className="flex-1 min-w-0">

                        <h2 className="text-2xl sm:text-3xl font-bold text-slate-800 tracking-tight truncate" title={productName}>

                            {mainDish}

                        </h2>

                        {extras && (

                            <p className="text-sm text-slate-500 truncate -mt-1">

                                {extras}

                            </p>

                        )}

                        {/* START: FIX - Display extracted characteristics */}

                        {characteristics.length > 0 && (

                            <div className="text-xs font-semibold text-green-700 uppercase tracking-wider mt-1">

                                {characteristics.join(' • ')}

                            </div>

                        )}

                        {/* END: FIX */}

                    </div>

                    {trustScore && (

                        <p className="text-sm text-slate-500 whitespace-nowrap flex-shrink-0">

                            Trust: {trustScore}%

                        </p>

                    )}

                </div>


                <div className="relative my-4">

                    <svg className="w-40 h-40 transform -rotate-90 mx-auto" viewBox="0 0 120 120">

                        <circle className="stroke-slate-200" cx="60" cy="60" r="52" strokeWidth="12" fill="transparent" />

                        <circle className={styles.stroke} cx="60" cy="60" r="52" strokeWidth="12" fill="transparent" strokeDasharray={circumference} strokeDashoffset={strokeDashoffset} strokeLinecap="round" style={{ transition: 'stroke-dashoffset 0.8s ease-out' }} />

                    </svg>

                    <div className="absolute inset-0 flex flex-col items-center justify-center">

                        <span className={`text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r ${styles.gradient}`}>{finalScore}</span>

                        <span className="text-sm text-slate-500 -mt-1">/ 100</span>

                    </div>

                </div>


                {!overrideReason && <NutritionInfo data={nutrients} />}


                <div className={`text-center px-3 py-1 rounded-full text-sm font-bold tracking-wide ${styles.bg} ${styles.text} mt-4`}>{category}</div>

                

                {isBestInClass && !overrideReason && (

                    <div className="mt-2 flex items-center justify-center gap-1.5 text-amber-500">

                        <StarIcon className="w-5 h-5" />

                        <span className="font-bold text-sm tracking-wide">BEST IN CLASS</span>

                    </div>

                )}


                {overrideReason && (

                    <div className="w-full mt-4 p-3 text-center bg-red-100 border border-red-200 rounded-lg">

                        <p className="text-sm font-bold text-red-800">Safety Override by AI</p>

                        <p className="text-xs text-red-700 mt-1">{overrideReason}</p>

                    </div>

                )}


                <div className="flex-grow w-full flex flex-col mt-4 overflow-hidden">

                    {finalScore < 90 && !overrideReason && (healthierAddon || topInCategory) && (

                         <div className="w-full pt-2">

                             <h4 className="text-xl font-medium text-slate-700 text-center mb-3 tracking-tight">Better Choices</h4>

                             <div className="space-y-3">

                                <SuggestionCard 

                                    title="Healthier Add-on" item={healthierAddon} onSearch={() => handleSuggestionSearch(healthierAddon.productName)}

                                    icon={<ArrowUpRightIcon className="w-6 h-6 text-green-600" />}

                                    bgColor="bg-green-50/80" borderColor="border-green-200/50" titleColor="text-green-700"

                                />

                                <SuggestionCard 

                                    title="Top of Category" item={topInCategory} onSearch={() => handleSuggestionSearch(topInCategory.productName)}

                                    icon={<SparklesIcon className="w-6 h-6 text-amber-500" />}

                                    bgColor="bg-amber-50/80" borderColor="border-amber-200/50" titleColor="text-amber-600"

                                />

                             </div>

                         </div>

                    )}

                </div>

                <div className="w-full text-xs mt-auto flex-shrink-0 pt-2">

                    <button onClick={() => setIsExpanded(!isExpanded)} className="text-slate-500 font-bold w-full text-center py-1">{isExpanded ? 'Hide' : 'Show'} Breakdown</button>

                    {isExpanded && (

                        <div className="mt-1 p-2 bg-slate-50 rounded-lg max-h-24 overflow-y-auto">

                            <AdjustmentRow adj={{ reason: 'Baseline', points: breakdown.baseScore }} />

                            {breakdown.adjustments.map((adj, i) => <AdjustmentRow key={i} adj={adj} />)}

                        </div>

                    )}

                    <button onClick={onReset} className="w-full mt-2 text-center text-sm font-bold tracking-wide text-slate-700 bg-slate-200 hover:bg-slate-300 rounded-lg py-2 transition-colors flex-shrink-0">Analyze Another</button>

                </div>

            </div>

        );

    };

    const ScoreDisplay = memo(_ScoreDisplay);


    const LoadingState = memo(() => ( <div className="w-full max-w-md h-[550px] mx-auto bg-white/60 backdrop-blur-xl rounded-3xl border border-slate-200 shadow-lg p-6 flex flex-col justify-center items-center text-center"><ArrowPathIcon className="w-12 h-12 text-slate-500 animate-spin" /><p className="mt-4 text-lg text-slate-600">AI is analyzing...</p><p className="text-sm text-slate-500 mt-1">This can take a moment.</p></div>));

    const _ErrorState = ({ message, onReset }) => ( <div className="w-full max-w-md h-[550px] mx-auto bg-white/60 backdrop-blur-xl rounded-3xl border border-slate-200 shadow-lg p-6 flex flex-col justify-center items-center text-center"><p className="text-xl font-medium text-red-600 tracking-tight">Analysis Failed</p><p className="text-sm text-slate-500 mt-2 px-4">{message}</p><button onClick={onReset} className="mt-6 text-sm font-bold tracking-wide text-white bg-slate-800 hover:bg-slate-700 rounded-lg py-2 px-4 transition-colors">Try Again</button></div>);

    const ErrorState = memo(_ErrorState);


    // --- Main App Component ---

    function App() {

        const [ultraScore, setUltraScore] = useState(null);

        const [isLoading, setIsLoading] = useState(false);

        const [error, setError] = useState(null);

        const resultsRef = useRef(null);


        const handleSearch = useCallback(async (term, image, originalScore = null) => {

            setIsLoading(true); setError(null); setUltraScore(null);

            setTimeout(() => resultsRef.current?.scrollIntoView({ behavior: 'smooth' }), 100);

            try {

                const analysis = await analyzeProduct(term, image);

                const initialScoreObject = calculateUltraScore(analysis);

                let finalScoreData = await performCommonSenseCheck(analysis, initialScoreObject);


                if (originalScore !== null && finalScoreData.finalScore < originalScore) {

                    const correctedScore = Math.min(100, originalScore + 5);

                    const rawNewScore = finalScoreData.finalScore;


                    let newCategory = 'Avoid';

                    if (correctedScore >= 90) newCategory = 'Excellent';

                    else if (correctedScore >= 70) newCategory = 'Good';

                    else if (correctedScore >= 50) newCategory = 'Moderate';

                    else if (correctedScore >= 30) newCategory = 'Limit';


                    const correctedData = {

                        ...finalScoreData,

                        finalScore: correctedScore,

                        category: newCategory,

                        breakdown: {

                            ...finalScoreData.breakdown,

                            adjustments: [

                                ...finalScoreData.breakdown.adjustments,

                                { reason: 'Improvement', points: correctedScore - rawNewScore }

                            ]

                        }

                    };

                    finalScoreData = correctedData;

                }


                setUltraScore(finalScoreData);

            } catch (err) {

                 setError(err instanceof Error ? err.message : "An unknown error occurred.");

            } finally {

                setIsLoading(false);

            }

        }, []);

        

        const handleReset = useCallback(() => {

             setUltraScore(null); setError(null); setIsLoading(false);

             window.scrollTo({ top: 0, behavior: 'smooth' });

        }, []);

        

        const showResults = isLoading || error || ultraScore;


        return (

            <React.Fragment>

                <style>{` @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.6; } 50% { transform: scale(1.15); opacity: 1; } } @keyframes fade-in { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } } .animate-fade-in { animation: fade-in 0.5s ease-out forwards; } .bg-gradient-radial { background-image: radial-gradient(circle, var(--tw-gradient-stops)); } `}</style>

                <div className="relative min-h-screen w-full overflow-hidden bg-white text-slate-900 antialiased">

                    <GrainyAuroraBackground />

                    <Header />

                    <main className="relative z-10">

                        <section className="pt-28 pb-12 sm:pt-40 sm:pb-20">

                            <div className="container mx-auto max-w-7xl px-6">

                                <div className="max-w-3xl mx-auto text-center">

                                    <h1 className="text-4xl leading-snug sm:text-5xl md:text-6xl font-semibold tracking-tighter">

                                        <span className="bg-clip-text text-transparent bg-gradient-to-r from-red-500 to-orange-500">Scan. </span>

                                        <span className="bg-clip-text text-transparent bg-gradient-to-r from-yellow-400 to-amber-500">Score. </span>

                                        <span className="bg-clip-text text-transparent bg-gradient-to-r from-lime-500 to-green-600">Decide.</span>

                                    </h1>

                                    <p className="mt-4 max-w-xl mx-auto text-lg text-slate-600">

                                        The AI-powered app for health-scoring{' '}

                                        <span className="font-bold text-slate-700">everything. </span>

                                         Instantly understand the impact of any product on your well-being.

                                    </p>

                                    <SearchBar onSearch={handleSearch} isLoading={isLoading} />

                                </div>

                                

                                <div ref={resultsRef} className={`transition-opacity duration-500 ${showResults ? 'opacity-100' : 'opacity-0'}`}>

                                    <div className={`flex justify-center items-start ${showResults ? 'mt-12 sm:mt-16 min-h-[550px]' : ''}`}>

                                        {isLoading && <LoadingState />}

                                        {error && <ErrorState message={error} onReset={handleReset} />}

                                        {ultraScore && <ScoreDisplay scoreData={ultraScore} onReset={handleReset} onSearch={handleSearch} />}

                                    </div>

                                </div>


                            </div>

                        </section>

                        <section className="py-16 sm:py-24 bg-slate-50">

                            <div className="container mx-auto max-w-5xl px-6">

                                <div className="mx-auto max-w-2xl text-center">

                                    <h2 className="text-3xl sm:text-4xl font-bold text-slate-900 tracking-tight">How It Works</h2>

                                    <p className="mt-4 text-lg sm:text-xl text-slate-600">A simple, three-step process to understand what's really in the products you use every day.</p>

                                </div>

                                <div className="mt-16 grid grid-cols-1 gap-8 md:grid-cols-3">

                                    <FeatureCard icon={<ScanIcon className="h-8 w-8" />} title="1. Scan or Search" description="Use your camera to scan a label or barcode, or just type in a product name."/>

                                    <FeatureCard icon={<GaugeIcon className="h-8 w-8" />} title="2. Get Your Score" description="Our AI objectively analyzes food and personal care products using a data-driven system."/>

                                    <FeatureCard icon={<DecideIcon className="h-8 w-8" />} title="3. Make Better Choices" description="Receive a clear 0-100 score and actionable insights to improve your well-being."/>

                                </div>

                            </div>

                        </section>

                    </main>

                    <div className="container mx-auto max-w-4xl px-6 pb-8 text-center text-sm text-slate-500">

                        <p>*The AI-powered analysis is for informational purposes only and may not be 100% accurate. It is not a substitute for professional medical or nutritional advice. Always verify product information with the manufacturer.</p>

                    </div>

                    <footer className="relative z-10 border-t border-slate-200 bg-white">

                        <div className="container mx-auto max-w-7xl px-6 py-8 text-center text-sm text-slate-500">

                            <p>&copy; 2025 ULTRASCORE Inc. All rights reserved.</p>

                        </div>

                    </footer>

                </div>

            </React.Fragment>

        );

    }


    // --- Mount the App ---

    const rootElement = document.getElementById('root');

    const root = ReactDOM.createRoot(rootElement);

    root.render(<App />);

</script>

</body>

</html>
